---
title: MySQL 面试题
date: 2024/10/10
description: MySQL 面试题
categories: 
  - 面试题
tags: 
  - MySQL
---

# :triangular_flag_on_post:InnoDB 与 MyISAM 的区别

[**MyISAM：**]{.yellow}

1. 不支持事务，但每次查询都是原子性的；
2. 支持表级锁，即每次操作都是整个表加锁；
3. 存储表的总行数；
4. 一个 MyISAM 表有 3 个文件：索引文件、表结构文件、数据文件；
5. 采用非聚集索引，索引文件的数据域存储指向数据文件的指针，辅索引和主索引基本一致，但是辅索引不用保证唯一性。

[InnoDB：]{.yellow}

1. 支持 ACID 的事务，支持事务的 4 种隔离级别；
2. 支持行级锁及外键约束，因此可以支持写并发；
3. 不存储表的总行数；
4. 一个 InnoDB 引擎存储在一个文件空间（共享表空间、表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空间，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制；
5. 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引树；索引最好使用自增主键，防止插入数据时，为维持 B+ 树结构，文件的大小调整。

# :triangular_flag_on_post:常见的索引类型有哪些？

1. [普通索引]{.yellow}：允许被索引的数据列包含重复的值。
2. [唯一索引]{.yellow}：可以保证数据记录的唯一性。[主键]{.red}：是一种特殊的唯一索引，在 一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用 PRIMARY KEY 来创建。
3. [联合索引]{.yellow}：索引可以覆盖多个数据列，如 [INDEX(column A, column B)]{.red} 索引。
4. [全文索引]{.yellow}：通过建立 倒排索引 ,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过 [ALTER TABLE table_name ADD FULLTEXT(column)]{.red}，创建全文索引索引可以极大的提高数据的查询速度。

:::info

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。

:::

# :triangular_flag_on_post:什么情况下会导致索引失效？

1. where 后面使用函数
2. 相同字段使用 or
3. 模糊查询 % 放在前边
4. 类型转换
5. 联合索引，最佳左前缀匹配原则

# :triangular_flag_on_post:如何优化 SQL？

1. 避免使用 * 号
2. 使用 like 模糊查询，% 不要放在前面
3. 使用 where 后面不要使用函数
4. 相同的索引字段不要使用 or 条件
5. 类型不匹配查询

# :triangular_flag_on_post:ACID 是什么？ACID 靠什么保证？

- A = Atomicity 原子性：
- C = Consistency 一致性：
- I = Isolation 隔离性：
- D = Durability 持久性：

# :triangular_flag_on_post:并发事务带来哪些问题？怎么解决？

- [脏读]{.rainbow}： 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- [不可重复读]{.rainbow}：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- [幻读]{.rainbow}：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

[脏读]{.red}

* [读已提交]{.rainbow}

* [可重复度]{.rainbow}

* [串行化]{.rainbow}

[不可重复度]{.red}

* [可重复度]{.rainbow}

* [串行化]{.rainbow}

[幻读]{.red}

* [MVCC]{.rainbow} + [间隙锁]{.rainbow}

* [串行化]{.rainbow}

# :triangular_flag_on_post:MySQL 的隔离级别有哪些？默认隔离级别是？

查看隔离级别

```sql 查看隔离级别
select @@transaction_isolation;
```

- [读未提交]{.rainbow}（read uncommitted）

  一个事务还没提交时，它修改的数据都可以被别的事务看到。

- [读已提交]{.rainbow}（read committed）

  一个事务提交之后，它修改的数据才会被别的事务看到。

- [可重复读]{.rainbow}（repeatable read)

  一个事务执行过程中看到的数据，总是和这个事务开启时看到的数据是一致的。在可重复读的隔离级别下，未提交的事务对其他事务也是不可见的。

- [串行化]{.rainbow}（serializable）

# MySQL 中的 MVCC 是什么？





# MySQL 如何定位慢查询？



